---
title: "PCA_Nowcast_CANGDP"
output: word_document
---

I) Data preparation step

```{r}
#### Loading the data 
STATCAN_data<-read.table("statcan.txt") # make sure statcan.txt is in your working directory
m <- ncol(STATCAN_data)
STATCAN_data <- STATCAN_data[,2:m] #The first column contains the dates, so it's not important 
STATCAN_names <-c("Y1_HOURS","X1_HOURSMAN","X2_HOURSWSRT","Y2_CPI","Y3_EMP","Y4_USCAN","Y5_ROWCAN","Y6_CANUS","Y7_CANROW","Y8_RAIL","Y9_DOM","Y10_TRAN","Y11_INT","Y12_MSM","Y13_MRTS","Y14_IMP","Y15_EXP","Y16_GDP")
colnames(STATCAN_data) <- STATCAN_names
str(STATCAN_data) # check the type of object - at this moment this is 'data.frame', we need 'Time Series'
```


```{r}
#### Removing the time series with strong seasonality
toremove=c(which(colnames(STATCAN_data) == "Y3_EMP"),which(colnames(STATCAN_data) == "Y9_DOM"),which(colnames(STATCAN_data) == "Y10_TRAN"),which(colnames(STATCAN_data) == "Y11_INT"))
STATCAN_data <- subset(STATCAN_data, select=-toremove)

```

```{r}
#### Converting the dataframe object to a time series object (monthly data)
STATCAN_ts<-ts(STATCAN_data,frequency=12, class = c("ts")) 
```



```{r}
#### Making the time series stationary


#Now the time series will be transformed to make them stationary. To achieve that, I'll difference them once (i.e Yt will be replaced by Yt-Yt-1).
#For this I use the Bpanel(base,trans,....) function (in the nowcasting package). 
#It's first argument "base" contains the time series to transform. 
#The second argument indicates "trans" is a vector whose ith element indicates the transformation to do on the ith time series of "base". if this ith element is 2, then the ith time series will be differenced once.

library(nowcasting)
Transformations <- as.integer(rep(1,ncol(STATCAN_ts))) #vector of transformations for the Bpanel() function. the inner function returns something of type "num" and as.integer() converts it to something of type "int".
STATCAN_ts.stat <- Bpanel(base = STATCAN_ts, trans = Transformations) #There are 12 NAs at the end of each time series. Those are used in the nowcasting function for the out of sample forecasts. The function will not work without them.

```


```{r}
#Removing the means for each time series
seriesmeans <- as.vector(colMeans(STATCAN_ts.stat[1:181,]))
meansmatrix <- matrix(rep(seriesmeans,nrow(STATCAN_ts.stat)),nrow = nrow(STATCAN_ts.stat),byrow = TRUE)
STATCAN_ts.stat <- STATCAN_ts.stat - meansmatrix
```


```{r}
#### Storing the dependent variable (GDP) and the independent variables


gdp_position_CANGDP <- which(colnames(STATCAN_ts.stat) == "Y16_GDP") # which column contains GDP;

x_CANGDP <- STATCAN_ts.stat[,-gdp_position_CANGDP]
y_CANGDP <- STATCAN_ts.stat[,gdp_position_CANGDP]

data_CANGDP <- cbind(y_CANGDP, x_CANGDP) #I put the GDP as the first column. This formating is necessary for the nowcasting function to work. 

#Removing the NAs for the PCA regression part
x_CANGDP <- na.omit(x_CANGDP, na.action = "exclude" ) 
y_CANGDP <- na.omit(y_CANGDP, na.action = "exclude")


#data_CANGDP

```



II) Comparing adjusted R^2, Y_t against S_t

```{r}

library(forecast)

#par(mfrow = c(2,2))
for (P in c(1)) # P is the number of lags considered in the nowcasting function
  {

  
  options(error = traceback) #to catch eventual errors
  
  #I go up to 12 factors/principal components
  #mses_2s = rep(0,12) #mean square errors for nowcasting
  #mses_pca = rep(0,12) ##mean square errors for PCA
  #ratio_2s_to_pca = rep(0,12) #mse_2s/mse_PCA for each number of factors/principal components
  #ratio_2s_to_fullpca = rep(0,12)
  #res_var_pca <- rep(0,12)
  #res_var_2s <- rep(0,12)
   
   
  #I go up to 12 factors/principal components
  adj_r2s_DFM = rep(0,12) #Adjusted R^2 for DFM
  adj_r2s_pca = rep(0,12) #Adjusted R^2 for PCA
  adj_r2s_TS = rep(0,12) #Adjusted R^2 for TS regression
  #ratio_DFM_to_pca = rep(0,12) #Ratio of DFM's R^2 to PCA's R^2 for each number of factors/principal components
  #ratio_DFM_to_TS = rep(0,12) #Ratio of DFM's R^2 to PCA's R^2 for each number of factors/principal components
  
   
  
   
  
  
  
  
   ###################################################################
   #### Principal component regression
   
   results.pca <- prcomp(x_CANGDP[1:nrow(x_CANGDP),], center=TRUE, scale = TRUE) #Doing PCA on the dependent variables x_CANGDP.The transformation I did on x_CANGDP above added 12 rows of NAs. I remove these rows before doing the PCA.
   pcs = results.pca$x #storing the principal components
   #cum_prop = b <- summary(results.pca)$importance[3,] #cumulative proportion of explained variance for each principal component
   
  
   for (k in 1:12)
      {  
      #regression using the first k principal components
      pca_reg <- lm(y_CANGDP~pcs[,1:k]+0)
      adj_r2s_pca[k]<- summary(pca_reg)$adj.r.squared
      #pca_res = pca_reg$residuals
      #hist(pca_res^2)
      #mse_pca <- sum((pca_res)^2)/length(pca_res)
      #mses_pca[k] <- mse_pca
      #res_var_pca[k]<-var(pca_res)
   }
   
   #mean square error by using all principal components
   #pca_reg <- lm(y_CANGDP~pcs[,1:13])
   #pca_res = pca_reg$residuals
   #mse_fullpca <- sum((pca_res)^2)/length(pca_res)
      
   
      
   ###################################################################
   #### Nowcasting
    
   #Frequency = as.integer(c(12,rep(12,ncol(x_CANGDP)))) #a vector containing the frequency of each time series in data_CANDGP. 12 implies that the observations are monthly;  4 implies that the observations are quaterly. this vector is used in the nowcast() function.
  
   
     
   for (k in 1:12)
   {
      
      DFM <- dynfactoR::dfm(x_CANGDP,r=k,p=P)
      DFM_reg <- lm(y_CANGDP~DFM$twostep+0)
      #Adjusted R^2
      adj_r2s_DFM[k]<- summary(DFM_reg)$adj.r.squared
      
      
      
     #Performs the nowcasting for k factors
     #print(data_CANGDP)
     #now2s <- nowcast(formula = y_CANGDP ~ ., data = data_CANGDP, r = k, p   = P, q = k, method = '2s', frequency = Frequency)
      
     #M=length(now2s$yfcst[,1])
     #A_2s=now2s$yfcst[,1]-now2s$yfcst[,2] # true value of Y - fitted value of Y 
     #A_2s=unclass(A_2s) # change 'Time Series' into a vector
     #A_2s=na.omit(A_2s) # get rid of 'NA'(if any)
     #mse_2s=sum(A_2s^2)/M #factor model square error
     #mses_2s[k] = mse_2s
     #ratio_2s_to_pca[k] = mses_2s[k]/mses_pca[k]
     #ratio_2s_to_fullpca[k] = mses_2s[k]/mse_fullpca
     #res_var_2s[k] <- var(A_2s)
   }
   
   
  
   
   ######################################################################
   #### Time series regression
   TS_reg <- lm(y_CANGDP~x_CANGDP+0)
   adj_r2s_TS<-rep(summary(TS_reg)$adj.r.squared,12)
   #TS_res <- TS_reg$residuals
   #mse_TS <- sum((TS_res)^2)/length(TS_res)
   #mses_TS <- rep(mse_TS,12)
   #res_var_TS <- var(TS_res)
   #res_var_TS<-rep(res_var_TS,12)
  
   
   
   
    
  if (P==1) {
     Title <- "p_v = 1, Y_t~S_t"
  }
  else if(P==2){
      Title <- "p = 2, Y_t~S_t"
  }
  else if (P==3){
     Title <- "p = 3, Y_t~S_t"
  }
   
   
 PCs_facts = c(1,2,3,4,5,6,7,8,9,10,11,12) 
 
 
 
 plot(PCs_facts,adj_r2s_pca,type="l",col="red",xlab = "Number of factors/principal components", ylab = "Adjusted R^2",main = Title,ylim = c(0.27,0.43))
lines(PCs_facts,adj_r2s_DFM,col="blue")
lines(PCs_facts,adj_r2s_TS,col="green")
legend("bottomright", legend=c("PCA","DFM","TS regression"),
       col=c("red", "blue", "green"),lty = c(1,1,1),cex=0.8)
 
#plot(PCs_facts,mses_pca,type="l",col="red",xlab = "Number of factors/principal components", ylab = "MSE",main = Title)#,ylim = c(min(mses_2s)-1000000,max(mses_pca)+1000000))
#lines(PCs_facts,mses_2s,col="blue")
#lines(PCs_facts,mses_TS,col="green")
#legend("topright", legend=c("PCA","DFM","TS regression"),
       #col=c("red", "blue", "green"),lty = c(1,1,1),cex=0.7)
 #print(ratio_2s_to_pca)
 #print(ratio_2s_to_fullpca)
 
 

#plot(PCs_facts,res_var_pca,type="l",col="red",xlab = "Number of factors/principal components", ylab = "variance of errors",main = Title,ylim = c(min(res_var_TS)-1000000,max(res_var_pca)+1000000))
#lines(PCs_facts,res_var_2s,col="blue")
#lines(PCs_facts,res_var_TS,col="green")
#legend("topright", legend=c("PCA","DFM","TS regression"),
       #col=c("red", "blue", "green"),lty = c(1,1,1),cex=0.7) 
  
#plot(PCs_facts,(res_var_2s/res_var_pca),type="l",col="red",xlab = "Number of factors/principal components", ylab = "Residuals variance ratio",main = Title,ylim = c(0.8,1.1) )
#lines(PCs_facts,(res_var_TS/res_var_2s),col="blue")
#lines(PCs_facts,(res_var_TS/res_var_pca),col="green")
#legend("topleft", legend=c("DFM/PCA","TS/DFM","TS/PCA"),
       #col=c("red", "blue", "green"),lty = c(1,1,1),cex=0.6) 
 
}
#plot(PCs_facts,mses_2s,type="l",col="blue",xlab = "Number of factors/principal components", ylab = "MSE",main = Title)
#lines(PCs_facts,mses_pca,col="red")
```


```{r}
adj_r2s_DFM
adj_r2s_pca
adj_r2s_TS
```





II) Comparing adjusted R^2, Y_t against S_t-1, S_t-2, S_t-3

```{r}
library(forecast)
samplesize <- nrow(as.matrix( y_CANGDP))

#par(mfrow = c(2,2))
for (P in c(1)) # P is the number of lags considered in the nowcasting function
  {

  
  options(error = traceback) #to catch eventual errors
  
  #I go up to 12 factors/principal components
  #mses_2s = rep(0,12) #mean square errors for nowcasting
  #mses_pca = rep(0,12) ##mean square errors for PCA
  #ratio_2s_to_pca = rep(0,12) #mse_2s/mse_PCA for each number of factors/principal components
  #ratio_2s_to_fullpca = rep(0,12)
  #res_var_pca <- rep(0,12)
  #res_var_2s <- rep(0,12)
   
   
  #I go up to 12 factors/principal components
  adj_r2s_DFM = rep(0,12) #Adjusted R^2 for DFM
  adj_r2s_pca = rep(0,12) #Adjusted R^2 for PCA
  adj_r2s_TS = rep(0,12) #Adjusted R^2 for TS regression
  #ratio_DFM_to_pca = rep(0,12) #Ratio of DFM's R^2 to PCA's R^2 for each number of factors/principal components
  #ratio_DFM_to_TS = rep(0,12) #Ratio of DFM's R^2 to PCA's R^2 for each number of factors/principal components
  
   
  
   
  
  
  
  
   ###################################################################
   #### Principal component regression
   
   results.pca <- prcomp(x_CANGDP[1:nrow(x_CANGDP),], center=TRUE, scale = TRUE) #Doing PCA on the dependent variables x_CANGDP.The transformation I did on x_CANGDP above added 12 rows of NAs. I remove these rows before doing the PCA.
   pcs = results.pca$x #storing the principal components
   #cum_prop = b <- summary(results.pca)$importance[3,] #cumulative proportion of explained variance for each principal component
   
   #reg_1lag <- lm(y_CANGDP[2:samplesize]~x_CANGDP[1:(samplesize-1),]+0)
   #reg_2lag <- lm(y_CANGDP[3:samplesize]~cbind(x_CANGDP[2:(samplesize-1),],x_CANGDP[1:(samplesize-2),])+0)
   #reg_3lag <- lm(y_CANGDP[4:samplesize]~cbind(x_CANGDP[3:(samplesize-1),],x_CANGDP[2:(samplesize-2),],x_CANGDP[1:(samplesize-3),])+0)
   
    
   for (k in 1:12)
      {  
      #regression using the first k principal components
      pca_reg <- lm(y_CANGDP[4:samplesize]~cbind(pcs[3:(samplesize-1),1:k],pcs[2:(samplesize-2),1:k],pcs[1:(samplesize-3),1:k])+0)
      adj_r2s_pca[k]<- summary(pca_reg)$adj.r.squared
      #pca_res = pca_reg$residuals
      #hist(pca_res^2)
      #mse_pca <- sum((pca_res)^2)/length(pca_res)
      #mses_pca[k] <- mse_pca
      #res_var_pca[k]<-var(pca_res)
   }
   
   #mean square error by using all principal components
   #pca_reg <- lm(y_CANGDP~pcs[,1:13])
   #pca_res = pca_reg$residuals
   #mse_fullpca <- sum((pca_res)^2)/length(pca_res)
      
   
      
   ###################################################################
   #### Nowcasting
    
   #Frequency = as.integer(c(12,rep(12,ncol(x_CANGDP)))) #a vector containing the frequency of each time series in data_CANDGP. 12 implies that the observations are monthly;  4 implies that the observations are quaterly. this vector is used in the nowcast() function.
  
   
     
   for (k in 1:12)
   {
      
      DFM <- dynfactoR::dfm(x_CANGDP,r=k,p=P)
      factors <- DFM$twostep
      DFM_reg <- lm(y_CANGDP[4:samplesize]~cbind(factors[3:(samplesize-1),1:k],factors[2:(samplesize-2),1:k],factors[1:(samplesize-3),1:k])+0)
      #DFM_reg <- lm(y_CANGDP~DFM$twostep+0)
      #Adjusted R^2
      adj_r2s_DFM[k]<- summary(DFM_reg)$adj.r.squared
      
      
      
     #Performs the nowcasting for k factors
     #print(data_CANGDP)
     #now2s <- nowcast(formula = y_CANGDP ~ ., data = data_CANGDP, r = k, p   = P, q = k, method = '2s', frequency = Frequency)
      
     #M=length(now2s$yfcst[,1])
     #A_2s=now2s$yfcst[,1]-now2s$yfcst[,2] # true value of Y - fitted value of Y 
     #A_2s=unclass(A_2s) # change 'Time Series' into a vector
     #A_2s=na.omit(A_2s) # get rid of 'NA'(if any)
     #mse_2s=sum(A_2s^2)/M #factor model square error
     #mses_2s[k] = mse_2s
     #ratio_2s_to_pca[k] = mses_2s[k]/mses_pca[k]
     #ratio_2s_to_fullpca[k] = mses_2s[k]/mse_fullpca
     #res_var_2s[k] <- var(A_2s)
   }
   
   
  
   
   ######################################################################
   #### Time series regression
   TS_reg <- lm(y_CANGDP[4:samplesize]~cbind(x_CANGDP[3:(samplesize-1),],x_CANGDP[2:(samplesize-2),],x_CANGDP[1:(samplesize-3),])+0)
   #TS_reg <- lm(y_CANGDP~x_CANGDP+0)
   adj_r2s_TS<-rep(summary(TS_reg)$adj.r.squared,12)
   #TS_res <- TS_reg$residuals
   #mse_TS <- sum((TS_res)^2)/length(TS_res)
   #mses_TS <- rep(mse_TS,12)
   #res_var_TS <- var(TS_res)
   #res_var_TS<-rep(res_var_TS,12)
  
   
   
   
    
  if (P==1) {
     Title <- "p_v = 1; Y_t ~ S_t-1,S_t-2,St-3"
  }
  else if(P==2){
      Title <- "p = 2; Y_t ~ S_t-1,S_t-2,St-3"
  }
  else if (P==3){
     Title <- "p = 3; Y_t ~ S_t-1,S_t-2,St-3"
  }
   
   
 PCs_facts = c(1,2,3,4,5,6,7,8,9,10,11,12) 
 
 
 
 plot(PCs_facts,adj_r2s_pca,type="l",col="red",xlab = "Number of factors/principal components", ylab = "Adjusted R^2",main = Title,ylim = c(0.12,0.3))
lines(PCs_facts,adj_r2s_DFM,col="blue")
lines(PCs_facts,adj_r2s_TS,col="green")
legend("bottomright", legend=c("PCA","DFM","TS regression"),
       col=c("red", "blue", "green"),lty = c(1,1,1),cex=0.7)
 
#plot(PCs_facts,mses_pca,type="l",col="red",xlab = "Number of factors/principal components", ylab = "MSE",main = Title)#,ylim = c(min(mses_2s)-1000000,max(mses_pca)+1000000))
#lines(PCs_facts,mses_2s,col="blue")
#lines(PCs_facts,mses_TS,col="green")
#legend("topright", legend=c("PCA","DFM","TS regression"),
       #col=c("red", "blue", "green"),lty = c(1,1,1),cex=0.7)
 #print(ratio_2s_to_pca)
 #print(ratio_2s_to_fullpca)
 
 

#plot(PCs_facts,res_var_pca,type="l",col="red",xlab = "Number of factors/principal components", ylab = "variance of errors",main = Title,ylim = c(min(res_var_TS)-1000000,max(res_var_pca)+1000000))
#lines(PCs_facts,res_var_2s,col="blue")
#lines(PCs_facts,res_var_TS,col="green")
#legend("topright", legend=c("PCA","DFM","TS regression"),
       #col=c("red", "blue", "green"),lty = c(1,1,1),cex=0.7) 
  
#plot(PCs_facts,(res_var_2s/res_var_pca),type="l",col="red",xlab = "Number of factors/principal components", ylab = "Residuals variance ratio",main = Title,ylim = c(0.8,1.1) )
#lines(PCs_facts,(res_var_TS/res_var_2s),col="blue")
#lines(PCs_facts,(res_var_TS/res_var_pca),col="green")
#legend("topleft", legend=c("DFM/PCA","TS/DFM","TS/PCA"),
       #col=c("red", "blue", "green"),lty = c(1,1,1),cex=0.6) 
 
}
#plot(PCs_facts,mses_2s,type="l",col="blue",xlab = "Number of factors/principal components", ylab = "MSE",main = Title)
#lines(PCs_facts,mses_pca,col="red")
```






```{r}
adj_r2s_DFM
adj_r2s_pca
adj_r2s_TS
```












II) Comparing adjusted R^2, Y_t against S_t-1, S_t-2

```{r}
library(forecast)
samplesize <- nrow(as.matrix( y_CANGDP))

par(mfrow = c(2,2))
for (P in 1:3) # P is the number of lags considered in the nowcasting function
  {

  
  options(error = traceback) #to catch eventual errors
  
  #I go up to 12 factors/principal components
  #mses_2s = rep(0,12) #mean square errors for nowcasting
  #mses_pca = rep(0,12) ##mean square errors for PCA
  #ratio_2s_to_pca = rep(0,12) #mse_2s/mse_PCA for each number of factors/principal components
  #ratio_2s_to_fullpca = rep(0,12)
  #res_var_pca <- rep(0,12)
  #res_var_2s <- rep(0,12)
   
   
  #I go up to 12 factors/principal components
  adj_r2s_DFM = rep(0,12) #Adjusted R^2 for DFM
  adj_r2s_pca = rep(0,12) #Adjusted R^2 for PCA
  adj_r2s_TS = rep(0,12) #Adjusted R^2 for TS regression
  #ratio_DFM_to_pca = rep(0,12) #Ratio of DFM's R^2 to PCA's R^2 for each number of factors/principal components
  #ratio_DFM_to_TS = rep(0,12) #Ratio of DFM's R^2 to PCA's R^2 for each number of factors/principal components
  
   
  
   
  
  
  
  
   ###################################################################
   #### Principal component regression
   
   results.pca <- prcomp(x_CANGDP[1:nrow(x_CANGDP),], center=TRUE, scale = TRUE) #Doing PCA on the dependent variables x_CANGDP.The transformation I did on x_CANGDP above added 12 rows of NAs. I remove these rows before doing the PCA.
   pcs = results.pca$x #storing the principal components
   #cum_prop = b <- summary(results.pca)$importance[3,] #cumulative proportion of explained variance for each principal component
   
   #reg_1lag <- lm(y_CANGDP[2:samplesize]~x_CANGDP[1:(samplesize-1),]+0)
   #reg_2lag <- lm(y_CANGDP[3:samplesize]~cbind(x_CANGDP[2:(samplesize-1),],x_CANGDP[1:(samplesize-2),])+0)
   #reg_3lag <- lm(y_CANGDP[4:samplesize]~cbind(x_CANGDP[3:(samplesize-1),],x_CANGDP[2:(samplesize-2),],x_CANGDP[1:(samplesize-3),])+0)
   
    
   for (k in 1:12)
      {  
      #regression using the first k principal components
      pca_reg <- lm(y_CANGDP[3:samplesize]~cbind(pcs[2:(samplesize-1),1:k],pcs[1:(samplesize-2),1:k])+0)
      adj_r2s_pca[k]<- summary(pca_reg)$adj.r.squared
      #pca_res = pca_reg$residuals
      #hist(pca_res^2)
      #mse_pca <- sum((pca_res)^2)/length(pca_res)
      #mses_pca[k] <- mse_pca
      #res_var_pca[k]<-var(pca_res)
   }
   
   #mean square error by using all principal components
   #pca_reg <- lm(y_CANGDP~pcs[,1:13])
   #pca_res = pca_reg$residuals
   #mse_fullpca <- sum((pca_res)^2)/length(pca_res)
      
   
      
   ###################################################################
   #### Nowcasting
    
   #Frequency = as.integer(c(12,rep(12,ncol(x_CANGDP)))) #a vector containing the frequency of each time series in data_CANDGP. 12 implies that the observations are monthly;  4 implies that the observations are quaterly. this vector is used in the nowcast() function.
  
   
     
   for (k in 1:12)
   {
      
      DFM <- dynfactoR::dfm(x_CANGDP,r=k,p=P)
      factors <- DFM$twostep
      DFM_reg <- lm(y_CANGDP[3:samplesize]~cbind(factors[2:(samplesize-1),1:k],factors[1:(samplesize-2),1:k])+0)
      #DFM_reg <- lm(y_CANGDP~DFM$twostep+0)
      #Adjusted R^2
      adj_r2s_DFM[k]<- summary(DFM_reg)$adj.r.squared
      
      
      
     #Performs the nowcasting for k factors
     #print(data_CANGDP)
     #now2s <- nowcast(formula = y_CANGDP ~ ., data = data_CANGDP, r = k, p   = P, q = k, method = '2s', frequency = Frequency)
      
     #M=length(now2s$yfcst[,1])
     #A_2s=now2s$yfcst[,1]-now2s$yfcst[,2] # true value of Y - fitted value of Y 
     #A_2s=unclass(A_2s) # change 'Time Series' into a vector
     #A_2s=na.omit(A_2s) # get rid of 'NA'(if any)
     #mse_2s=sum(A_2s^2)/M #factor model square error
     #mses_2s[k] = mse_2s
     #ratio_2s_to_pca[k] = mses_2s[k]/mses_pca[k]
     #ratio_2s_to_fullpca[k] = mses_2s[k]/mse_fullpca
     #res_var_2s[k] <- var(A_2s)
   }
   
   
  
   
   ######################################################################
   #### Time series regression
   TS_reg <- lm(y_CANGDP[4:samplesize]~cbind(x_CANGDP[3:(samplesize-1),],x_CANGDP[2:(samplesize-2),],x_CANGDP[1:(samplesize-3),])+0)
   #TS_reg <- lm(y_CANGDP~x_CANGDP+0)
   adj_r2s_TS<-rep(summary(TS_reg)$adj.r.squared,12)
   #TS_res <- TS_reg$residuals
   #mse_TS <- sum((TS_res)^2)/length(TS_res)
   #mses_TS <- rep(mse_TS,12)
   #res_var_TS <- var(TS_res)
   #res_var_TS<-rep(res_var_TS,12)
  
   
   
   
    
  if (P==1) {
     Title <- "p = 1; Y_t ~ S_t-1,S_t-2,St-2"
  }
  else if(P==2){
      Title <- "p = 2; Y_t ~ S_t-1,S_t-2,St-2"
  }
  else if (P==3){
     Title <- "p = 3; Y_t ~ S_t-1,S_t-2,St-2"
  }
   
   
 PCs_facts = c(1,2,3,4,5,6,7,8,9,10,11,12) 
 
 
 
 plot(PCs_facts,adj_r2s_pca,type="l",col="red",xlab = "Number of factors/principal components", ylab = "Adjusted R^2",main = Title,ylim = c(0.12,0.36))
lines(PCs_facts,adj_r2s_DFM,col="blue")
lines(PCs_facts,adj_r2s_TS,col="green")
legend("topleft", legend=c("PCA","DFM","TS regression"),
       col=c("red", "blue", "green"),lty = c(1,1,1),cex=0.4)
 
#plot(PCs_facts,mses_pca,type="l",col="red",xlab = "Number of factors/principal components", ylab = "MSE",main = Title)#,ylim = c(min(mses_2s)-1000000,max(mses_pca)+1000000))
#lines(PCs_facts,mses_2s,col="blue")
#lines(PCs_facts,mses_TS,col="green")
#legend("topright", legend=c("PCA","DFM","TS regression"),
       #col=c("red", "blue", "green"),lty = c(1,1,1),cex=0.7)
 #print(ratio_2s_to_pca)
 #print(ratio_2s_to_fullpca)
 
 

#plot(PCs_facts,res_var_pca,type="l",col="red",xlab = "Number of factors/principal components", ylab = "variance of errors",main = Title,ylim = c(min(res_var_TS)-1000000,max(res_var_pca)+1000000))
#lines(PCs_facts,res_var_2s,col="blue")
#lines(PCs_facts,res_var_TS,col="green")
#legend("topright", legend=c("PCA","DFM","TS regression"),
       #col=c("red", "blue", "green"),lty = c(1,1,1),cex=0.7) 
  
#plot(PCs_facts,(res_var_2s/res_var_pca),type="l",col="red",xlab = "Number of factors/principal components", ylab = "Residuals variance ratio",main = Title,ylim = c(0.8,1.1) )
#lines(PCs_facts,(res_var_TS/res_var_2s),col="blue")
#lines(PCs_facts,(res_var_TS/res_var_pca),col="green")
#legend("topleft", legend=c("DFM/PCA","TS/DFM","TS/PCA"),
       #col=c("red", "blue", "green"),lty = c(1,1,1),cex=0.6) 
 
}
#plot(PCs_facts,mses_2s,type="l",col="blue",xlab = "Number of factors/principal components", ylab = "MSE",main = Title)
#lines(PCs_facts,mses_pca,col="red")
```






```{r}
adj_r2s_DFM
adj_r2s_pca
adj_r2s_TS
```






II) Comparing adjusted R^2, Y_t against S_t-1

```{r}
library(forecast)
samplesize <- nrow(as.matrix( y_CANGDP))

par(mfrow = c(2,2))
for (P in 1:3) # P is the number of lags considered in the nowcasting function
  {

  
  options(error = traceback) #to catch eventual errors
  
  #I go up to 12 factors/principal components
  #mses_2s = rep(0,12) #mean square errors for nowcasting
  #mses_pca = rep(0,12) ##mean square errors for PCA
  #ratio_2s_to_pca = rep(0,12) #mse_2s/mse_PCA for each number of factors/principal components
  #ratio_2s_to_fullpca = rep(0,12)
  #res_var_pca <- rep(0,12)
  #res_var_2s <- rep(0,12)
   
   
  #I go up to 12 factors/principal components
  adj_r2s_DFM = rep(0,12) #Adjusted R^2 for DFM
  adj_r2s_pca = rep(0,12) #Adjusted R^2 for PCA
  adj_r2s_TS = rep(0,12) #Adjusted R^2 for TS regression
  #ratio_DFM_to_pca = rep(0,12) #Ratio of DFM's R^2 to PCA's R^2 for each number of factors/principal components
  #ratio_DFM_to_TS = rep(0,12) #Ratio of DFM's R^2 to PCA's R^2 for each number of factors/principal components
  
   
  
   
  
  
  
  
   ###################################################################
   #### Principal component regression
   
   results.pca <- prcomp(x_CANGDP[1:nrow(x_CANGDP),], center=TRUE, scale = TRUE) #Doing PCA on the dependent variables x_CANGDP.The transformation I did on x_CANGDP above added 12 rows of NAs. I remove these rows before doing the PCA.
   pcs = results.pca$x #storing the principal components
   #cum_prop = b <- summary(results.pca)$importance[3,] #cumulative proportion of explained variance for each principal component
   
   #reg_1lag <- lm(y_CANGDP[2:samplesize]~x_CANGDP[1:(samplesize-1),]+0)
   #reg_2lag <- lm(y_CANGDP[3:samplesize]~cbind(x_CANGDP[2:(samplesize-1),],x_CANGDP[1:(samplesize-2),])+0)
   #reg_3lag <- lm(y_CANGDP[4:samplesize]~cbind(x_CANGDP[3:(samplesize-1),],x_CANGDP[2:(samplesize-2),],x_CANGDP[1:(samplesize-3),])+0)
   
    
   for (k in 1:12)
      {  
      #regression using the first k principal components
      pca_reg <- lm(y_CANGDP[2:samplesize]~pcs[1:(samplesize-1),1:k]+0)
      adj_r2s_pca[k]<- summary(pca_reg)$adj.r.squared
      #pca_res = pca_reg$residuals
      #hist(pca_res^2)
      #mse_pca <- sum((pca_res)^2)/length(pca_res)
      #mses_pca[k] <- mse_pca
      #res_var_pca[k]<-var(pca_res)
   }
   
   #mean square error by using all principal components
   #pca_reg <- lm(y_CANGDP~pcs[,1:13])
   #pca_res = pca_reg$residuals
   #mse_fullpca <- sum((pca_res)^2)/length(pca_res)
      
   
      
   ###################################################################
   #### Nowcasting
    
   #Frequency = as.integer(c(12,rep(12,ncol(x_CANGDP)))) #a vector containing the frequency of each time series in data_CANDGP. 12 implies that the observations are monthly;  4 implies that the observations are quaterly. this vector is used in the nowcast() function.
  
   
     
   for (k in 1:12)
   {
      
      DFM <- dynfactoR::dfm(x_CANGDP,r=k,p=P)
      factors <- DFM$twostep
      DFM_reg <- lm(y_CANGDP[2:samplesize]~factors[1:(samplesize-1),1:k]+0)
      #DFM_reg <- lm(y_CANGDP~DFM$twostep+0)
      #Adjusted R^2
      adj_r2s_DFM[k]<- summary(DFM_reg)$adj.r.squared
      
      
      
     #Performs the nowcasting for k factors
     #print(data_CANGDP)
     #now2s <- nowcast(formula = y_CANGDP ~ ., data = data_CANGDP, r = k, p   = P, q = k, method = '2s', frequency = Frequency)
      
     #M=length(now2s$yfcst[,1])
     #A_2s=now2s$yfcst[,1]-now2s$yfcst[,2] # true value of Y - fitted value of Y 
     #A_2s=unclass(A_2s) # change 'Time Series' into a vector
     #A_2s=na.omit(A_2s) # get rid of 'NA'(if any)
     #mse_2s=sum(A_2s^2)/M #factor model square error
     #mses_2s[k] = mse_2s
     #ratio_2s_to_pca[k] = mses_2s[k]/mses_pca[k]
     #ratio_2s_to_fullpca[k] = mses_2s[k]/mse_fullpca
     #res_var_2s[k] <- var(A_2s)
   }
   
   
  
   
   ######################################################################
   #### Time series regression
   TS_reg <- lm(y_CANGDP[4:samplesize]~cbind(x_CANGDP[3:(samplesize-1),],x_CANGDP[2:(samplesize-2),],x_CANGDP[1:(samplesize-3),])+0)
   #TS_reg <- lm(y_CANGDP~x_CANGDP+0)
   adj_r2s_TS<-rep(summary(TS_reg)$adj.r.squared,12)
   #TS_res <- TS_reg$residuals
   #mse_TS <- sum((TS_res)^2)/length(TS_res)
   #mses_TS <- rep(mse_TS,12)
   #res_var_TS <- var(TS_res)
   #res_var_TS<-rep(res_var_TS,12)
  
   
   
   
    
  if (P==1) {
     Title <- "p = 1; Y_t ~ S_t-1,S_t-2,St-2"
  }
  else if(P==2){
      Title <- "p = 2; Y_t ~ S_t-1,S_t-2,St-2"
  }
  else if (P==3){
     Title <- "p = 3; Y_t ~ S_t-1,S_t-2,St-2"
  }
   
   
 PCs_facts = c(1,2,3,4,5,6,7,8,9,10,11,12) 
 
 
 
 plot(PCs_facts,adj_r2s_pca,type="l",col="red",xlab = "Number of factors/principal components", ylab = "Adjusted R^2",main = Title,ylim = c(0.12,0.36))
lines(PCs_facts,adj_r2s_DFM,col="blue")
lines(PCs_facts,adj_r2s_TS,col="green")
legend("topleft", legend=c("PCA","DFM","TS regression"),
       col=c("red", "blue", "green"),lty = c(1,1,1),cex=0.4)
 
#plot(PCs_facts,mses_pca,type="l",col="red",xlab = "Number of factors/principal components", ylab = "MSE",main = Title)#,ylim = c(min(mses_2s)-1000000,max(mses_pca)+1000000))
#lines(PCs_facts,mses_2s,col="blue")
#lines(PCs_facts,mses_TS,col="green")
#legend("topright", legend=c("PCA","DFM","TS regression"),
       #col=c("red", "blue", "green"),lty = c(1,1,1),cex=0.7)
 #print(ratio_2s_to_pca)
 #print(ratio_2s_to_fullpca)
 
 

#plot(PCs_facts,res_var_pca,type="l",col="red",xlab = "Number of factors/principal components", ylab = "variance of errors",main = Title,ylim = c(min(res_var_TS)-1000000,max(res_var_pca)+1000000))
#lines(PCs_facts,res_var_2s,col="blue")
#lines(PCs_facts,res_var_TS,col="green")
#legend("topright", legend=c("PCA","DFM","TS regression"),
       #col=c("red", "blue", "green"),lty = c(1,1,1),cex=0.7) 
  
#plot(PCs_facts,(res_var_2s/res_var_pca),type="l",col="red",xlab = "Number of factors/principal components", ylab = "Residuals variance ratio",main = Title,ylim = c(0.8,1.1) )
#lines(PCs_facts,(res_var_TS/res_var_2s),col="blue")
#lines(PCs_facts,(res_var_TS/res_var_pca),col="green")
#legend("topleft", legend=c("DFM/PCA","TS/DFM","TS/PCA"),
       #col=c("red", "blue", "green"),lty = c(1,1,1),cex=0.6) 
 
}
#plot(PCs_facts,mses_2s,type="l",col="blue",xlab = "Number of factors/principal components", ylab = "MSE",main = Title)
#lines(PCs_facts,mses_pca,col="red")
```



```{r}
adj_r2s_DFM
adj_r2s_pca
adj_r2s_TS
```





```{r}
#now2s$factors$A[27:36,]
#e = matrix(c(1:16),4,4)
#e
#e[,-1]

#e <- x_CANGDP
#e
#ts(rbind (e, c(1:13)), frequency = 12)

#as.vector(pca_reg$coefficients)
#results.pca$x
```

 
 
 
 

